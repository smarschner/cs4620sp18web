<!-- <h1><strong>PA 7: Ray2</strong></h1> -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<h3> Written part</h3>
<p class="duedate">Due:  Friday April 27th 2018 (11:59pm)</p>
<p> 1. 1D Monte Carlo Integration<p>
Consider the integral:
$$\int_0^2 e^{-2x} \, dx$$
<p> a.) Compute the analytic solution to this integral. <p>
<p> b.) Write down a Monte Carlo estimator for this integral using uniform sampling. <p>
<p> c.) Implement the Monte Carlo estimation in (b) (You can choose whatever language you like). For a given number of samples \(n\), you can measure how accurate your estimate is by doing \(m\) trials and computing the average absolute difference between the analytic solution and the Monte Carlo estimate.  Make a plot of the error as a function of the number of samples, on a log-log scale, using the number of samples 16, 32, 64, ..., 65536.  What can you say from the plot about how the error changes with the number of samples? 


<p> 2. 2D Monte Carlo Integration and shading <p>
Consider a scene where a square light source is standing vertically on a planar Lambertian surface.  The light is in the \(z=0\) plane, covering the area \(0 \le y \le 1\) and \(-\frac{1}{2} \le x \le \frac{1}{2}\), and the surface is in the \(y=0\) plane.  In lecture, we talked about two ways to formulate the problem of computing the light reflected from ths surface.  One is an integral over points on the the light; let's see how this approach performs using Monte Carlo integration for shading points on the \(z\) axis at 0.1, 1, and 10 units away from the light. The diffuse reflectance of the Lambertian surface is \(k_r=0.5\). The square light source radiance equals to 1 and is uniform across the source area.
<p>a.) For each of the three shading point, write out the reflected radiance as an integral over the light's area, as a function of \(x\) and \(y\).  Use your favorite plotting software to visualize the integrand, for instance as a height-field plot or a color-mapped square image, for each of the three shading points.</p>
<p>b.) Compute the correct answer to this 2D integration problem for each of the three shading points using Wolfram Alpha or a similar tool.</p>
<p>c.) Write down a Monte Carlo estimator for this integral using uniform sampling over the light source area and compute the mean and standard deviation of 1000 samples of this estimator.  In which case does it give the lowest and highest relative error (measured as standard deviation divided by the true answer), and, briefly, why? <p>

3. (Continue with problem 2.)<p>
Now we want to compute the same integral using a different strategy, integrating over directions at the receiving point.  In this case, the integrand is defined on the hemisphere of unit vector directions \(\omega_i\), and its value is 1 if the ray \((\mathbf{x}, \omega_i)\) hits the light, and 0 otherwise. We'll use the probability density \(p(\omega_i) = \cos\theta / \pi\) where \(\theta\) is the angle between the surface normal and \(\omega_i\).

<p>a.) We can generate unit vectors in this cosine distribution in cylindrical coordinates, using the following equations. Start with two random variables \(s_1, s_2 \in [0, 1]\), which gives us a uniform sample from a unit square. The relationship between uniform samples in the unit square and cosine-distributed samples on the unit hemisphere is:
\[ r = \sqrt{s_1}\]
\[ \phi = 2\pi s_2\]
\[ z = \sqrt{1 - r^2}\]
where \(r\) and \(\phi\) are polar coordinates in the \(x\)-\(y\) plane, and z is the height above the plane.  (A better approach is based on a "concentric" mapping from the unit square to the unit circle, but this one will do).  Use the above formula to implement a function that produces points on the hemisphere, and demonstrate that the points are cosine-distributed using a histogram: bin 10,000 random points in to 100 equal-sized bins in theta, and make a plot of the fraction of samples in each bin divided by the soild angle of the bin, as a function of \(\theta\).  Compare the results to the expected distribution \(p(\omega_i)\).  (Remember the solid angle of a region on the hemisphere is just its surface area, treating the hemisphere as having unit radius.)

<p>b.) If a ray starts from the point \((0, 0, z_0)\) with direction \((x_d, y_d, z_d)\), for what values of these coordinates does it hit the light?  Your answer is going to be inequalities joined with "and."

<p>c.) Now that you have a procedure to generate samples (a), and a way to evaluate the integrand (b), repeat part (c) from problem 2 using this new strategy.  For which distances does the cosine-based sampling outperform the rectangle-based sampling?


<h3> Programming part</h3>
<p class="duedate">Due:  Wednesday May 9th 2018 (11:59pm)</p>

<p>
In this assignment you will implement the core algorithms in a modern ray tracer.  We provide the low-level components&mdash;the BSDFs, the light sources, the geometry and ray tracing code&mdash;and you implement the Monte Carlo illumination computations.  Specifically, you will implement the subclasses of the abstract class<tt>Integrator</tt>.

<p>
There are two parts to this assignment, corresponding to the two fundamental ways to sample illumination: using probability distributions that follow the BSDF of the surface, or using probability distributions that follow the distribution of incident light at the surface.  These two strategies are handled by the integrators <tt>LightSamplingIntegrator</tt> and <tt>BSDFSamplingIntegrator</tt>.  There is one warm-up step, to implement a simple Ray 1 style integrator called <tt>PointLightIntegrator</tt>.  And there is an extra credit step, which is to implement the integrator <tt>MISIntegrator</tt> that intelligently combines the light sampling and BSDF sampling approaches to get (nearly) the best of both worlds.

<p>
Step 1: implement the point light integrator.  This one loops over all lights, checking to be sure they are point lights, and does the simple computation with BRDF and one-over-r-squared.  It doesn't call Light.sample or BSDF.sample, and area lights and environments don't produce any illumination.  There are reflections of point sources but not of environments or other objects.  Question: could we make this include glazed and glass with traditional deterministic methods?

<p>
Step 2: implement light source sampling.  This one behaves more as a path tracer: it selects one light and samples a direction from it.  Do we describe it as integrating over light source points?  It uses shadow rays so that lights will block other lights, which means it is in some sense a light-surface integration method, not a hemisphere integration method.  It also computes illumination from environments by sampling proportional to the environment.  As a bonus, it computes recursive contributions only from delta reflections and refractions.  When this step is done, many scenes will work well, but not reflections of large lights in shiny surfaces.

<p>
Step 3: implement BSDF sampling.  This is actually almost simpler: you select a direction, trace a ray, and only pay attention to light coming from sources. You use the BRDF and pdf values to compute an estimator.  Reflections from mirror surfaces happen naturally, and I think we might want to have the rule that discrete reflections are followed recursively.  When this step is done, some scenes that did not work well before will render successfully, but many that previously worked OK will get missed.

<p>
Step 4: Multiple Importance Sampling.  For this, you paste the two previous parts together and merge them using the Balance Heuristic.  If you manage to get all the parts in the right places, this will be a program capable of rendering some pretty nice lighting effects.
